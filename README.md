# Post-haste
A no_std, alloc-free async Rust library for creating modular projects.

## Summary
The goal of this library is to provide a framework for a highly modularised code base.
There are two core components around which this framework is based: the Agent and the Postmaster.

### Agents
Functionality of the application is divided up between a number of modules, dubbed "Agents".
Each Agent is expected to have a single responsibility.
Post-haste provides the Agent trait, which defines the interface for Agents and gives them the ability to be integrated into the rest of the system.
The defining features of an Agent are an instantiation function: `create()`, a task loop: `run()`, and an inbox.

The `create()` function is called automatically when the Agent is "registered" (see [Registering Agents](#registering-agents) below).
The body of this function should instantiate the Agent and populate it with any configuration it requires.
The `Config` associated type is used to assist in this.

The `run()` function is the Agent's main loop.
This is spawned as a standalone task in the executor, and is not expected to return (i.e. the lifetime of Agents is expected to be the same as the lifetime of the application).
When an Agent is registered, it is assigned a mailbox.
The receiving end of the mailbox (the inbox) is passed in as an argument to the `run()` function.
In the vast majority of cases, the core logic of the Agent's loop will be to await messages arriving in its inbox and perform actions based on what is received.

### The Postmaster
The postmaster provides the mechanism by which Agents are able to communicate, and by which data moves around the system.
The postmaster requires two enum types to be defined: the message `Payload` and the `Address` list.
The `Payload` enum defines all the messages which are defined for the application, while the `Address` enum provides addresses for all Agents present.

When an Agent wishes to communicate with another Agent, it calls one of the postmaster's globally accessible send functions, providing at minimum a message payload, a destination address and a source address.
The payload and source address are encapsulated into a `Message` struct (auto generated by the `init_postmaster!()` macro), and the `Message` is delivered to the Agent at the destination address.

Please note: the `Message` and `Address` associated types in the `Agent` trait correspond to the auto-generated `Message` type and the user-provided `Address` list respectively.
I have so far not come up with a way to eliminate this boiler-plate.

## Example usage
```rust
#[no_std]


```

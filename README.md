# Post-haste
A no_std, alloc-free async Rust library for creating modular projects.

## Summary
The goal of this library is to provide a framework for a highly modularised code base.
There are two core components around which this framework is based: the Agent and the Postmaster.

### Agents
Functionality of the application is divided up between a number of modules, dubbed "Agents".
Each Agent is expected to have a single responsibility.
Post-haste provides the Agent trait, which defines the interface for Agents and gives them the ability to be integrated into the rest of the system.
The defining features of an Agent are an instantiation function: `create()`, a task loop: `run()`, and an inbox.

The `create()` function is called automatically when the Agent is "registered" (see [Registering Agents](#registering-agents) below).
The body of this function should instantiate the Agent and populate it with any configuration it requires.
The `Config` associated type is used to assist in this.

The `run()` function is the Agent's main loop.
This is spawned as a standalone task in the executor, and is not expected to return (i.e. the lifetime of Agents is expected to be the same as the lifetime of the application).
When an Agent is registered, it is assigned a mailbox.
The receiving end of the mailbox (the inbox) is passed in as an argument to the `run()` function.
In the vast majority of cases, the core logic of the Agent's loop will be to await messages arriving in its inbox and perform actions based on what is received.

### The Postmaster
The postmaster provides the mechanism by which Agents are able to communicate, and by which data moves around the system.
The postmaster requires two enum types to be defined: the message `Payload` and the `Address` list.
The `Payload` enum defines all the messages which are defined for the application, while the `Address` enum provides addresses for all Agents present.

When an Agent wishes to communicate with another Agent, it calls one of the postmaster's globally accessible send functions, providing at minimum a message payload, a destination address and a source address.
The payload and source address are encapsulated into a `Message` struct (auto generated by the `init_postmaster!()` macro), and the `Message` is delivered to the Agent at the destination address.

Please note: the `Message` and `Address` associated types in the `Agent` trait correspond to the auto-generated `Message` type and the user-provided `Address` list respectively.
I have so far not come up with a way to eliminate this boiler-plate.

## Example usage
The following forms the core of the code layout for a baremetal project built upon post_haste (excluding any architecture-specific code and dependencies):
```rust
#![no_std]

use embassy_executor::Spawner;

use post_haste::agent::Agent;
use post_haste::init_postmaster;

/// The list of Agent addresses, used to identify the source and destination for messages.
/// Each Agent must have a unique address
enum Address {
  AgentA,
  AgentB,
  // ...
}

/// Top-level definition of messages used in the system.
enum Payloads {
  General(GeneralPayloads),
  // ...
}

/// A sub-category of messages (this heirachical ordering isn't necessary, but is highly recommended for organisation)
enum GeneralPayloads {
  Hello,
  // ...
}

// Generates the postmaster logic and initialises the postmaster for use within the project
init_postmaster!(Address, Payloads);

struct MyAgent {
  address: Address
}

impl Agent for MyAgent {
  type Address = Address;
  type Message = postmaster::Message;
  type Config = ();

  async fn create(address: Self::Address, _: Self::Config) -> Self {
    // Initialisation code goes here...
    Self { address }
  }

  async fn run(self, inbox: post_haste::agent::Inbox<Self::Message>) -> ! {
    loop {
      let received_message = inbox.recv().await.unwrap();
      match received_message {
        Payloads::Hello => postmaster::send(received_message.source, self.address, Payloads::Hello).await.unwrap();
        // ...
      }
    }
  }
}

#[embassy_executor::main]
async fn main(spawner: Spawner) {
  const QUEUE_SIZE: usize = 8;
  postmaster::register_agent!(spawner, AgentA, MyAgent, ());
  postmaster::register_agent!(spawner, AgentB, MyAgent, (), QUEUE_SIZE);

  loop {
    // ...
  }
}
```

While the framework was originally developed for no_std baremetal environments, it is also fully compatible with tokio.
- [tokio_basic.rs](examples/tokio_basic.rs) gives a very simple example of two Agents exchanging messages.
- [showcase.rs](examples/showcase.rs) follows the same concept, but aims to demonstrate some useful patterns within the framework.

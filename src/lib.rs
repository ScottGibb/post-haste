#![cfg_attr(target_os = "none", no_std)]

pub mod agent;
pub mod error;

#[cfg(not(target_os = "none"))]
pub mod async_runtime_dependencies {
    pub use once_cell::sync::Lazy;
    pub use tokio::sync::Mutex;
    pub use tokio::sync::mpsc::{Receiver, Sender, channel};
    pub use tokio::task;
    pub use tokio::time;
    pub use tokio::time::Duration;
}
#[cfg(target_os = "none")]
pub mod async_runtime_dependencies {
    pub use embassy_executor::{SpawnToken, Spawner, task};
    pub use embassy_sync::{
        blocking_mutex::raw::NoopRawMutex,
        channel::{Channel, DynamicSender},
        mutex::Mutex,
    };
    pub use embassy_time::{Duration, Timer, WithTimeout};
}
pub mod dependencies {
    pub use crate::async_runtime_dependencies::*;
    pub use const_env::from_env;
    pub use portable_atomic::{AtomicU32, AtomicUsize};
}
pub use error::PostmasterError;

/// Initialise the Postmaster for use in your project.
/// As the code for the Postmaster is no_std, it requires information about the project.
/// Therefore, the code must be generated by a macro within the host crate.
/// This macro takes two arguments: an enum type defining the Agent addresses, and an enum type defining the message payloads
/// The output of the macro is the `postmaster` module, which contains the API for the Postmaster.
///
/// # Notes
/// The logic generated by this macro relies on the (currently) unstable feature `variant_count`.
/// Therefore the project must be built with the nightly compiler and you will need to include this feature at the top of the file (see example).
///
/// # Examples
/// ```rust
/// #![feature(variant_count)]
///
/// use post_haste::init_postmaster;
///
/// enum Address {
///   AgentOne,
///   AgentTwo,
/// }
///
/// enum Payloads {
///   Hello,
///   AByte(u8),
///   DataResponse{ acknowledged: bool },
///   // ...
/// }
///
/// init_postmaster!(Address, Payloads);
/// ```
#[macro_export]
macro_rules! init_postmaster {

    ($address_enum:ty, $payload_enum:ty, $timeout_us: expr) => {
        /// API module for the Postmaster
        /// This module contains all of the functions required to pass messages between Agents, facilitated by the Postmaster.
        ///
        /// Begin by registering Agents with the `postmaster::register_agent!()` macro.
        /// Once this is done you can send the Agent a message by calling one of the messaging functions, e.g. `postmaster::send()`.
        #[allow(clippy::crate_in_macro_def)]
        pub mod postmaster {
            use super::{$address_enum, $payload_enum};
            use post_haste::PostmasterError;
            use post_haste::dependencies::*;

            const ADDRESS_COUNT: usize = core::mem::variant_count::<$address_enum>();

            /// Initialises an Agent and its message queue
            /// This macro both instantiates an Actor and kicks off its main loop.
            /// It also creates the message queue for the Agent at the provided address, so that messages sent to that address will be delivered specifically to that Agent instance.
            /// As well as the address and Agent type this macro also requires an instance of the Agent's associated Config type which is used during the instantiation of the Agent, and an optional queue size parameter which dictates the number of messages the Agent's message queue can hold.
            /// If no queue size parameter is given this defaults to 1, meaning that if there is already a message waiting in an Agent's queue then any attempt to send a message to the Agent will have to wait until either the queued message is received, or the send timeout is reached (in which case message sending is considered a failure).
            /// If try_send() is used to send to a full message queue, it will immediately return with failure.
            #[macro_export]
            #[cfg(not(target_os = "none"))]
            macro_rules! register_agent {
                ($agent_address:ident, $agent:ty, $config:expr, $queue_size: expr) => {{
                    use crate::postmaster::Message;
                    use post_haste::agent::Agent;
                    use post_haste::dependencies::*;
                    struct Mailbox {
                        pub sender: Sender<Message>,
                        pub receiver: Receiver<Message>,
                    }
                    let (sender, receiver) = channel::<Message>($queue_size);

                    let agent = <$agent>::create(<$address_enum>::$agent_address, $config).await;
                    postmaster::register(<$address_enum>::$agent_address, sender).await.inspect(|_|{

                        tokio::task::spawn(async move {
                            agent.run(receiver).await;
                        });
                    })
                }};
                ($agent_address:ident, $agent:ty, $config:expr) => {
                    register_agent!($agent_address, $agent, $config, 1)
                };
            }

            /// Initialises an Agent and its message queue.
            /// This macro both instantiates an Actor and kicks off its main loop.
            /// It also creates the message queue for the Agent at the provided address, so that messages sent to that address will be delivered specifically to that Agent instance.
            /// As well as the address and Agent type this macro also requires an instance of the Agent's associated Config type which is used during the instantiation of the Agent, and an optional queue size parameter which dictates the number of messages the Agent's message queue can hold.
            /// If no queue size parameter is given this defaults to 1, meaning that if there is already a message waiting in an Agent's queue then any attempt to send a message to the Agent will have to wait until either the queued message is received, or the send timeout is reached (in which case message sending is considered a failure).
            /// If try_send() is used to send to a full message queue, it will immediately return with failure.
            #[macro_export]
            #[cfg(target_os = "none")]
            macro_rules! register_agent {
                ($spawner:ident, $agent_address:ident, $agent:ty, $config:expr, $queue_size: expr) => {{
                    use post_haste::dependencies::{NoopRawMutex, Channel, task};
                    use post_haste::agent::Agent;
                    use crate::postmaster::Message;
                    struct Mailbox {
                        pub inner: Channel<NoopRawMutex, Message, $queue_size>
                    }

                    unsafe impl Sync for Mailbox{}
                    static MAILBOX: Mailbox = Mailbox{ inner: Channel::new()};

                    let agent = <$agent>::create(<$address_enum>::$agent_address, $config).await;
                    postmaster::register(<$address_enum>::$agent_address, MAILBOX.inner.sender().into()).await.inspect(|_| {

                        #[task]
                        async fn run_agent(agent: $agent) {
                            agent.run(MAILBOX.inner.receiver().into()).await
                        }
                        $spawner.must_spawn(run_agent(agent));
                    })
                }};
                ($spawner:ident, $agent_address:ident, $agent:ty, $config:expr) => {
                    register_agent!($spawner, $agent_address, $agent, $config, 1)
                }
            }

            /// This function can be used to register a standalone address with the Postmaster.
            /// When registering an Agent (using the register_agent!() macro), the Agent's message queue is generated and assigned to the given address automatically.
            /// However, there may be some scenarios where you may want to register a message queue without tying it to an Agent.
            /// An example of this would be if you wanted to be able to receive messages on the main task, or providing a debug node for Agents to send diagnostics to.
            ///
            /// # Example
            /// ```rust
            /// // Assuming Postmaster has been initialised above...
            ///
            /// use embassy_executor::Spawner;
            /// use embassy_sync::channel::Channel;
            ///
            /// #[embassy_executor::main]
            /// async fn main(spawner: Spawner) {
            ///   let message_queue = Channel::new();
            ///   postmaster::register(Address::MainTask, message_queue.sender().into()).unwrap()
            ///
            ///   let receiver = message_queue.receiver();
            ///   loop {
            ///     let received_message = receiver.receive().await;
            ///     // Handle message...
            ///   }
            /// }
            /// ```
            #[cfg(target_os = "none")]
            pub async fn register(
                address: $address_enum,
                mailbox: DynamicSender<'static, Message>,
            ) -> Result<(), PostmasterError> {
                postmaster_internal::register(address, mailbox).await
            }

            /// This function can be used to register a standalone address with the Postmaster.
            /// When registering an Agent (using the register_agent!() macro), the Agent's message queue is generated and assigned to the given address automatically.
            /// However, there may be some scenarios where you may want to register a message queue without tying it to an Agent.
            /// An example of this would be if you wanted to be able to receive messages on the main task, or providing a debug node for Agents to send diagnostics to.
            ///
            /// # Example
            /// ```rust
            /// // Assuming Postmaster has been initialised above...
            ///
            /// use tokio::sync::mpsc::channel;
            ///
            /// #[tokio::main]
            /// async fn main() {
            ///   let (sender, receiver) = channel::<postmaster::Message>();
            ///   postmaster::register(Address::MainTask, sender).unwrap()
            ///
            ///   loop {
            ///     let received_message = receiver.recv().await.unwrap();
            ///     // Handle message...
            ///   }
            /// }
            /// ```
            #[cfg(not(target_os = "none"))]
            pub async fn register(
                address: $address_enum,
                mailbox: Sender<Message>,
            ) -> Result<(), PostmasterError> {
                postmaster_internal::register(address, mailbox).await
            }


            /// Send a message using the Postmaster's default timeout
            /// The Postmaster will attempt to push the message onto the destination Agent's queue.
            /// The future returned by this function will resolve when either:
            /// - The message was added to the queue successfully
            /// - The message could not be added to the queue before the timeout expired.
            /// Reasons for failure include:
            /// - The message queue being consistently full for longer than the timeout
            /// - The Postmaster being unable to acquire a lock on the senders before the timeout expires
            /// - There being no recipient registered at the destination address
            pub async fn send(
                destination: $address_enum,
                source: $address_enum,
                payload: $payload_enum,
            ) -> Result<(), PostmasterError> {
                postmaster_internal::send_internal(destination, Message { source, payload }, None)
                    .await
            }

            /// Attempt to send a message without waiting
            /// This function works very similarly to `postmaster::send()`, however if this is not immediately possible it will return with an error rather than attempting to wait for a timeout period.
            /// Reasons for failure include:
            /// - The recipient's message queue being full
            /// - The lock on the senders not being available
            /// - There being no recipient registered at the destination address
            pub fn try_send(
                destination: $address_enum,
                source: $address_enum,
                payload: $payload_enum,
            ) -> Result<(), PostmasterError> {
                postmaster_internal::try_send_internal(destination, Message { source, payload })
            }

            /// Begin building a message with custom settings
            /// The function takes a source and destination address and a payload, but instead of immediately attempting to send the message, it instead returns a MessageBuilder type.
            /// The MessageBuilder provides methods to further configure the message before it is sent.
            pub fn message(
                destination: $address_enum,
                source: $address_enum,
                payload: $payload_enum,
            ) -> MessageBuilder {
                MessageBuilder {
                    destination,
                    message: Message { source, payload },
                    timeout: None,
                    delay: None,
                }
            }

            /// Retrieve diagnostic information for the Postmaster
            /// The diagnostics contain information about how many messages have been sent in total since boot, and how many (if any) sending failures have occurred.
            /// This provides a simple high-level overview of the health of the system.
            pub fn get_diagnostics() -> Diagnostics {
                postmaster_internal::get_diagnostics()
            }

            /// Change the Postmaster's default timeout for sending messages
            pub fn set_timeout(timeout_us: u32) {
                postmaster_internal::set_timeout(timeout_us)
            }

            impl MessageBuilder {
                /// Add a custom timeout to the message.
                /// When the message is sent, it will use this timeout to determine how long to wait before giving up, rather than the Postmaster's default timeout.
                pub fn with_timeout(mut self, timeout: Duration) -> Self {
                    self.timeout.replace(timeout);
                    self
                }

                /// Add a delay to the message.
                /// The message is sent immediately, but the Postmaster will not attempt to push the message onto the recipient's queue until the delay has elapsed.
                /// **Please note** that if a delay is added to the message, but after the delay has elapsed the Postmaster is unable to deliver the message, there is no way for the Postmaster to relay this failure back to the sender.
                pub fn with_delay(mut self, delay: Duration) -> Self {
                    self.delay.replace(delay);
                    self
                }

                /// Send the configured message.
                /// This function works in exactly the same way as `postmaster::send()`, except that the timeout scenario may be different depending on whether the timeout for the message was customised.
                /// If a delay was set, the message will "send" immediately (meaning that the sender can continue executing), but the message won't be delivered until _at least_ the delay has elapsed.
                /// This function can fail for the following reasons:
                /// - The message queue being consistently full for longer than the timeout
                /// - The Postmaster being unable to acquire a lock on the senders before the timeout expires
                /// - There being no recipient registered at the destination address
                /// - If a delay was set, the Postmaster was unable to spawn a task to handle sending the message after the delay
                pub async fn send(self) -> Result<(), PostmasterError> {
                    match self.delay {
                        Some(delay) => {
                            postmaster_internal::spawn_delayed_send(
                                self.destination,
                                self.message,
                                delay,
                                self.timeout,
                            )
                            .await
                        }
                        None => {
                            postmaster_internal::send_internal(
                                self.destination,
                                self.message,
                                self.timeout,
                            )
                            .await
                        }
                    }
                }
            }

            /// The structure of a message in the system.
            /// This structure is automatically generated by the sending functions from the source address and the payload
            pub struct Message {
                /// The address from which the message originated
                pub source: $address_enum,
                /// The message contents
                pub payload: $payload_enum,
            }

            /// A builder for configuring messages.
            /// Provides methods for configuring the message before it is sent with the `send()` method
            pub struct MessageBuilder {
                destination: $address_enum,
                message: Message,
                timeout: Option<Duration>,
                delay: Option<Duration>,
            }

            /// Contains diagnostic information for the Postmaster.
            /// Obtained by calling postmaster::get_diagnostics()
            pub struct Diagnostics {
                /// The number of messages successfully sent since the Postmaster was initialised.
                pub messages_sent: usize,
                /// The number of messages which could not be sent since the Postmaster was initialised.
                pub send_failures: usize,
            }

            mod postmaster_internal {
                use super::{
                    ADDRESS_COUNT, Message, PostmasterError, $address_enum, $payload_enum,
                };
                use core::cell::RefCell;
                use core::sync::atomic::Ordering;
                use post_haste::dependencies::*;
                #[post_haste::dependencies::from_env]
                const DELAYED_MESSAGE_POOL_SIZE: usize = 8;

                #[cfg(target_os = "none")]
                type Mailbox = DynamicSender<Message>;
                #[cfg(not(target_os = "none"))]
                type Mailbox = Sender<Message>;

                pub(super) async fn register(
                    address: $address_enum,
                    mailbox: Mailbox,
                ) -> Result<(), PostmasterError> {
                    let mut senders = POSTMASTER.senders.lock().await;
                    if senders[address as usize].is_none() {
                        senders[address as usize].replace(mailbox);
                        Ok(())
                    } else {
                        return Err(PostmasterError::AddressAlreadyTaken);
                    }
                }

                pub(super) async fn send_internal(
                    destination: $address_enum,
                    message: Message,
                    timeout: Option<Duration>,
                ) -> Result<(), PostmasterError> {
                    let timeout = match timeout {
                        Some(duration) => duration,
                        None => Duration::from_micros(
                            POSTMASTER.timeout_us.load(Ordering::Relaxed).into(),
                        ),
                    };
                    #[cfg(not(target_os = "none"))]
                    evaluate_diagnostics(tokio::time::timeout(timeout, async {
                        match &POSTMASTER.senders.lock().await[destination as usize] {
                            None => Err(PostmasterError::NoRecipient),
                            Some(sender) => {
                                sender.send(message).await?;
                                Ok(())
                            }
                        }
                    })
                    .await
                    .map_err(|_| PostmasterError::Timeout)?)?;

                    #[cfg(target_os = "none")]
                    evaluate_diagnostics(
                        async {
                            match &POSTMASTER.senders.lock().await[destination as usize] {
                                None => Err(PostmasterError::NoRecipient),
                                Some(sender) => {
                                    sender.send(message).await;
                                    Ok(())
                                }
                            }
                        }
                        .with_timeout(timeout)
                        .await?,
                    )?;
                    Ok(())
                }

                pub(super) fn try_send_internal(
                    destination: $address_enum,
                    message: Message,
                ) -> Result<(), PostmasterError> {
                    evaluate_diagnostics(
                        match &POSTMASTER.senders.try_lock()?[destination as usize] {
                            None => Err(PostmasterError::NoRecipient),
                            Some(sender) => {
                                sender.try_send(message)?;
                                Ok(())
                            }
                        },
                    )
                }

                pub(super) async fn spawn_delayed_send(
                    destination: $address_enum,
                    message: Message,
                    delay: Duration,
                    timeout: Option<Duration>,
                ) -> Result<(), PostmasterError> {

                    #[cfg(not(target_os = "none"))]
                    {
                        let _ = tokio::spawn(delayed_send(destination, message, delay, timeout));
                        Ok(())
                    }
                    #[cfg(target_os = "none")]
                    if let Some(spawner) = *POSTMASTER.spawner.borrow(){
                            Ok(spawner.spawn(delayed_send(destination, message, delay, timeout))?)
                        } else {
                            send_internal(destination, message, timeout).await
                        }

                }

                #[cfg_attr(target_os = "none", task(pool_size=DELAYED_MESSAGE_POOL_SIZE))]
                pub(super) async fn delayed_send(
                    destination: $address_enum,
                    message: Message,
                    delay: Duration,
                    timeout: Option<Duration>,
                ) {
                    sleep(delay).await;
                    let source = message.source;
                    match send_internal(destination, message, timeout).await {
                        Ok(_) => (),
                        Err(error) => (), // TODO: Can we find a way to convey back to the source that the sending failed?
                    }
                }

                #[cfg_attr(target_os = "none", task(pool_size=DELAYED_MESSAGE_POOL_SIZE))]
                pub(super) async fn delayed_try_send(
                    destination: $address_enum,
                    message: Message,
                    delay: Duration,
                ) {
                    sleep(delay).await;
                    match try_send_internal(destination, message) {
                        Ok(_) => (),
                        Err(error) => (), // TODO: Can we find a way to convey back to the source that the sending failed?
                    }
                }

                pub(super) fn get_diagnostics() -> super::Diagnostics{
                    super::Diagnostics {
                        messages_sent: POSTMASTER.messages_sent.load(Ordering::Relaxed),
                        send_failures: POSTMASTER.send_failures.load(Ordering::Relaxed),
                    }
                }

                pub(super) fn set_timeout(timeout_us: u32) {
                    POSTMASTER.timeout_us.store(timeout_us, Ordering::Relaxed)
                }

                #[cfg(not(target_os = "none"))]
                struct Postmaster {
                    senders: Mutex<[Option<Mailbox>; ADDRESS_COUNT]>,
                    timeout_us: AtomicU32,
                    messages_sent: AtomicUsize,
                    send_failures: AtomicUsize,
                }
                #[cfg(not(target_os = "none"))]
                static POSTMASTER: Lazy<Postmaster> = Lazy::new(|| Postmaster {
                    senders: Mutex::new([const { None }; ADDRESS_COUNT]),
                    timeout_us: AtomicU32::new($timeout_us),
                    messages_sent: AtomicUsize::new(0),
                    send_failures: AtomicUsize::new(0),
                });

                #[cfg(target_os = "none")]
                unsafe impl Sync for Postmaster<'_> {}
                #[cfg(target_os = "none")]
                struct Postmaster<'a> {
                    senders:
                        Mutex<NoopRawMutex, [Option<DynamicSender<'a, Message>>; ADDRESS_COUNT]>,
                    timeout_us: AtomicU32,
                    spawner: RefCell<Option<Spawner>>,
                    messages_sent: AtomicUsize,
                    send_failures: AtomicUsize,
                }

                #[cfg(target_os = "none")]
                static POSTMASTER: Postmaster = Postmaster {
                    senders: Mutex::new([None; ADDRESS_COUNT]),
                    timeout_us: AtomicU32::new(100),
                    spawner: RefCell::new(None),
                    messages_sent: AtomicUsize::new(0),
                    send_failures: AtomicUsize::new(0),
                };

                #[inline]
                fn evaluate_diagnostics(
                    result: Result<(), PostmasterError>,
                ) -> Result<(), PostmasterError> {
                    result
                        .inspect(|_| {
                            POSTMASTER.messages_sent.fetch_add(1, Ordering::Relaxed);
                        })
                        .inspect_err(|_| {
                            POSTMASTER.send_failures.fetch_add(1, Ordering::Relaxed);
                        })
                }

                async fn sleep(delay: Duration){
                    #[cfg(target_os = "none")]
                    Timer::after(delay).await;
                    #[cfg(not(target_os = "none"))]
                    time::sleep(delay).await;

                }
            }
        }
    };
    ($address_enum:ty, $payload_enum:ty) => {
        init_postmaster!($address_enum, $payload_enum, 1000);
    };
}
